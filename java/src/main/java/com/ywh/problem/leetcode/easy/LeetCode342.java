package com.ywh.problem.leetcode.easy;

/**
 * 4 的幂
 * [位运算]
 *
 * 给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。
 * 整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4^x
 * 示例 1：
 *      输入：n = 16
 *      输出：true
 * 示例 2：
 *      输入：n = 5
 *      输出：false
 * 示例 3：
 *      输入：n = 1
 *      输出：true
 * 提示：
 *      -2^31 <= n <= 2^31 - 1
 * 进阶：
 *      你能不使用循环或者递归来完成本题吗？
 *
 * TODO 暂时未理解
 *
 * @author ywh
 * @since 5/30/2021
 */
public class LeetCode342 {

    /**
     * 如果 n 是 4 的幂，则 n 的二进制表示中有且仅有一个 1，
     * 并且这个 1 出现在从低位开始的第偶数个二进制位上（因为这个 1 后面必须有偶数个 0）。
     * 规定最低位为第 0 位，例如 n=16 时，n 的二进制表示为 (10000)2。
     *
     * 唯一的 1 出现在第 4 个二进制位上，因此 n 是 4 的幂。
     * 由于题目保证了 n 是 32 位的有符号整数，因此可以构造一个整数 mask，它的所有偶数二进制位都是 0，所有奇数二进制位都是 1。
     * 将 nn 和 mask 进行按位与运算，如果结果为 0，说明 n 二进制表示中的 1 出现在偶数的位置，否则说明其出现在奇数的位置。
     * mask 的二进制表示为：(10101010101010101010101010101010)2
     * 十六进制表示为：mask=(AAAAAAAA)16
     *
     * @param n
     * @return
     */
    public boolean isPowerOfFour(int n) {
        return n > 0 && (n & (n - 1)) == 0 && (n & 0xaaaaaaaa) == 0;
    }

    /**
     * 如果 n 是 4 的幂，它可以表示成 4^x 的形式，可以发现它除以 3 的余数一定为 1，
     * 即：4^x ≡ (3+1)^3 ≡ 1^x ≡ 1 (mod 3)
     * 如果 n 是 2 的幂却不是 4 的幂，它可以表示成 4^x * 2 的形式，此时它除以 3 的余数一定为 2。
     * 因此可以通过 n 除以 3 的余数是否为 1 来判断 n 是否是 4 的幂。
     *
     * @param n
     * @return
     */
    public boolean isPowerOfFour2(int n) {
        return (n & (n - 1)) == 0 && n % 3 == 1;
    }
}
